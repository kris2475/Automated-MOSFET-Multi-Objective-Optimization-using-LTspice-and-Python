import subprocess
import os
import time
import numpy as np
import matplotlib.pyplot as plt
# Import 3D plotting library
from mpl_toolkits.mplot3d import Axes3D 
from scipy.optimize import differential_evolution
from PyLTSpice.raw.raw_read import RawRead

# --- Global Data Storage ---
OPTIMIZATION_HISTORY = []

# --- Configuration & Paths ---
# IMPORTANT: Update this path to match your local LTspice installation executable path.
# NOTE: The trailing space has been removed to fix the SyntaxError: U+00A0
LTSPICE_PATH = r"C:\Users\Kris\AppData\Local\Programs\ADI\LTspice\LTspice.exe"
NETLIST_FILE = "optimization_transient.net"
RAW_FILE = NETLIST_FILE.replace('.net', '.raw') 

# Multi-Objective Penalty Factor: (Using 0.001 from the successful run)
AREA_PENALTY_FACTOR = 0.001

# --- LTspice Netlist Template ---
NETLIST_TEMPLATE = """
* NMOS Optimization Test with Parasitic Inductance
.title Automated MOSFET Optimization Test (Dynamic I_on)
Vdd Vdd_clean 0 DC 5 
Lp Vdd_clean Vdd_supply 1n
Vg G 0 PULSE(0 5 0 1n 1n 1u 2u)
Rload Vdd_supply D 1k
M1 D G 0 0 NMOS L={L_val}u W={W_val}u
.model NMOS NMOS (VTO=0.7 KP=120u)

.tran 0.1u 5u

.end
"""

def clean_up_files():
    """Removes temporary files (.net, .raw, .log) generated by the script and LTspice."""
    print("Cleaning up temporary files...")
    for f in [NETLIST_FILE, RAW_FILE, NETLIST_FILE.replace('.net', '.log')]: 
        if os.path.exists(f):
            try:
                os.remove(f)
            except OSError as e:
                print(f"Error removing file {f}: {e}")

def run_simulation_and_extract(L_microns, W_microns):
    """
    1. Generates the netlist for the given L and W.
    2. Runs the LTspice simulation in batch mode.
    3. Extracts the maximum I_on current from the resulting .raw file.
    
    :param L_microns: Channel Length (L) in microns.
    :param W_microns: Channel Width (W) in microns.
    :return: The maximum I_on current in Amps, or 0.0 on failure.
    """
    l_val = f"{L_microns:.6f}"
    w_val = f"{W_microns:.6f}"
    
    netlist_content = NETLIST_TEMPLATE.format(L_val=l_val, W_val=w_val)
    
    try:
        with open(NETLIST_FILE, "w") as f:
            f.write(netlist_content)
    except IOError:
        print("Error: Could not write netlist file.")
        return 0.0

    command = [LTSPICE_PATH, "-b", NETLIST_FILE]
    
    try:
        subprocess.run(command, check=True, capture_output=True, text=True, timeout=8) 
    except subprocess.CalledProcessError as e:
        print(f"Error: LTspice simulation failed. Stderr: {e.stderr}")
        return 0.0
    except subprocess.TimeoutExpired:
        print("Error: LTspice simulation timed out.")
        return 0.0
    except FileNotFoundError:
        print(f"Error: LTspice executable not found at: {LTSPICE_PATH}")
        return 0.0

    if os.path.exists(RAW_FILE):
        try:
            raw_data = RawRead(RAW_FILE)
            current_trace = raw_data.get_trace('I(Rload)')
            i_on_max = np.max(np.abs(current_trace.data))
            return i_on_max
        except Exception as e:
            return 0.0
    else:
        return 0.0

def objective_function(params):
    """
    The multi-objective cost function that the optimizer seeks to MINIMIZE.
    Cost = (-I_on) + (AREA_PENALTY_FACTOR * L * W)
    """
    L, W = params
    
    i_on = run_simulation_and_extract(L, W)
    
    area_microns_sq = L * W
    area_penalty = AREA_PENALTY_FACTOR * area_microns_sq
    
    cost = (-i_on) + area_penalty

    OPTIMIZATION_HISTORY.append({
        'L': L,
        'W': W,
        'I_on': i_on,
        'Cost': cost
    })
    
    print(f"L={L:.6f}u, W={W:.6f}u -> I_on={i_on:.6e} A, Area_Penalty={area_penalty:.6e}, Cost={cost:.6e}")
    
    return cost

def plot_optimization_results(history):
    """Generates and saves plots showing the optimization progress, including a 3D plot."""
    
    if not history:
        print("No optimization history to plot.")
        return
        
    # 1. Extract data from history
    iterations = np.arange(len(history))
    L_values = np.array([d['L'] for d in history])
    W_values = np.array([d['W'] for d in history])
    cost_values = np.array([d['Cost'] for d in history])
    i_on_values = np.array([d['I_on'] for d in history])
    
    # Use color mapping based on iteration number for the 3D plot
    colors = iterations
    
    # 2. Create the figure and subplots (Now 2 rows, 2 columns)
    fig = plt.figure(figsize=(14, 12))
    fig.suptitle('MOSFET Multi-Objective Optimization Progress (L-C Circuit)', fontsize=16)

    # --- Subplot 1: Cost Function Convergence (Top Left) ---
    ax1 = fig.add_subplot(2, 2, 1)
    ax1.plot(iterations, cost_values, label='Total Cost', color='red')
    ax1.set_ylabel('Cost (to Minimize)')
    ax1.set_title('A) Total Cost Convergence')
    ax1.grid(True, linestyle='--')
    
    # --- Subplot 2: Design Variables (L and W) (Top Right) ---
    ax2 = fig.add_subplot(2, 2, 2)
    ax2.plot(iterations, L_values, label='Length ($L$)', color='blue')
    ax2.plot(iterations, W_values, label='Width ($W$)', color='green')
    ax2.set_ylabel('Dimension ($\mu$m)')
    ax2.set_title('B) Design Variables ($L$ and $W$)')
    ax2.legend()
    ax2.grid(True, linestyle='--')
    
    # --- Subplot 3: I_on Output (Bottom Left) ---
    ax3 = fig.add_subplot(2, 2, 3)
    ax3.plot(iterations, i_on_values, label='$I_{on}$', color='purple')
    ax3.set_ylabel('$I_{on}$ (A)')
    ax3.set_xlabel('Simulation Iteration')
    ax3.set_title('C) $I_{on}$ Maximization Progress')
    ax3.ticklabel_format(axis='y', style='sci', scilimits=(-2, 2))
    ax3.grid(True, linestyle='--')
    
    # --- Subplot 4: 3D Visualization of the Search Path (Bottom Right) ---
    ax4 = fig.add_subplot(2, 2, 4, projection='3d')
    # Scatter plot of the history: (L, W, Cost)
    scatter = ax4.scatter(L_values, W_values, cost_values, 
                         c=colors, cmap='viridis', s=20) # Color by iteration
    # Plot a line connecting the points to show the path
    ax4.plot(L_values, W_values, cost_values, color='gray', linestyle='--', alpha=0.5)

    ax4.set_xlabel('L ($\mu$m)')
    ax4.set_ylabel('W ($\mu$m)')
    ax4.set_zlabel('Cost')
    ax4.set_title('D) 3D Search Path (L vs. W vs. Cost)')
    
    # Add a color bar to show iteration progression
    fig.colorbar(scatter, ax=ax4, label='Iteration Number')
    
    # Adjust layout to prevent overlap
    plt.tight_layout(rect=[0, 0.03, 1, 0.96])
    
    # Save the plot
    plot_filepath = "optimization_results.png"
    plt.savefig(plot_filepath)
    print(f"\nüìà Optimization plots saved to: {plot_filepath}")


def run_optimization():
    global OPTIMIZATION_HISTORY
    OPTIMIZATION_HISTORY.clear()
    
    # Optimization bounds: L and W ranges in microns
    # [(L_min, L_max), (W_min, W_max)]
    bounds = [(0.5, 5.0), (1.0, 100.0)]
    
    print("--- Starting MOSFET I_on/Area Optimization (Differential Evolution) ---")
    print(f"Optimization bounds: L in {bounds[0]} Œºm, W in {bounds[1]} Œºm")
    print(f"Area Penalty Factor: {AREA_PENALTY_FACTOR}")
    
    # Use differential_evolution for global search capability
    result = differential_evolution(
        func=objective_function,     # The function to minimize
        bounds=bounds,               # The search space boundaries
        maxiter=50,                  # Maximum number of generations
        popsize=15,                  # Population size per generation
        disp=True                    # Display optimization progress in console
    )
    
    # --- Final Result Display ---
    print("\n=======================================================")
    if result.success:
        L_opt, W_opt = result.x
        final_cost = result.fun 
        # Rerun simulation at the optimal point to get the clean I_on value for display
        I_on_opt = run_simulation_and_extract(L_opt, W_opt)
        
        print(f"‚úÖ Optimization Successful in {result.nit} generations.")
        print("--- Optimal Transistor Parameters ---")
        print(f"Optimal L: {L_opt:.4f} Œºm")
        print(f"Optimal W: {W_opt:.4f} Œºm")
        print(f"Optimal Area: {(L_opt * W_opt):.4f} Œºm¬≤")
        print("-------------------------------------")
        print(f"Final Cost (Minimizing): {final_cost:.6e}")
        print(f"Corresponding Max I_on (Peak Transient): {I_on_opt:.6e} A")
    else:
        print("‚ùå Optimization Failed:")
        print(result.message)
    print("=======================================================")

    plot_optimization_results(OPTIMIZATION_HISTORY)
    clean_up_files()


if __name__ == "__main__":
    try:
        # Check for required 3D plotting library import
        import numpy as np
        from scipy.optimize import differential_evolution 
        import matplotlib.pyplot as plt
        # The line below ensures the 3D projection works, but the module is imported above
        from mpl_toolkits.mplot3d import Axes3D 
    except ImportError as e:
        print(f"Required library missing: {e}")
        print("Please install required libraries using: pip install numpy scipy matplotlib PyLTSpice")
        exit()
    
    run_optimization()





























